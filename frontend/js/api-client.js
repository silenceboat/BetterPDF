/**
 * DeepRead AI - API Client
 *
 * Wrapper for Python backend API exposed via PyWebView.
 * All methods return Promises that resolve to the API response.
 */

const API = {
    /**
     * Check if running in PyWebView environment
     */
    isPyWebView() {
        return typeof pywebview !== 'undefined' && pywebview.api;
    },

    /**
     * Generic API call wrapper with error handling
     */
    async call(method, ...args) {
        if (!this.isPyWebView()) {
            console.warn('PyWebView not available, using mock response');
            return this.mockResponse(method, args);
        }

        try {
            const result = await pywebview.api[method](...args);
            return result;
        } catch (error) {
            console.error(`API call failed: ${method}`, error);
            return { success: false, error: error.message };
        }
    },

    /**
     * Mock responses for development without PyWebView
     */
    mockResponse(method, args) {
        const mocks = {
            open_pdf: () => ({
                success: true,
                file_path: '/path/to/sample.pdf',
                page_count: 42,
                file_name: 'sample.pdf',
                title: 'Sample Document',
                metadata: { page_count: 42 },
                session_state: {
                    last_page: 1,
                    last_zoom: 1.0,
                    ocr_enabled: false,
                    ocr_mode: 'page'
                },
                page_notes: []
            }),
            get_page: () => ({
                success: true,
                image_data: '', // Would be base64 in real response
                page_num: args[0],
                page_width: 595,
                page_height: 842
            }),
            extract_text: () => ({
                success: true,
                text: 'Sample extracted text from the PDF document.',
                page_num: args[0]
            }),
            ai_chat: () => ({
                success: true,
                response: 'This is a mock AI response. In production, this would be generated by the AI service.'
            }),
            ai_action: () => ({
                success: true,
                response: 'Mock AI action result for: ' + args[0]
            }),
            get_ai_settings: () => ({
                success: true,
                settings: {
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    base_url: '',
                    api_key: '',
                    has_api_key: false
                }
            }),
            save_ai_settings: () => ({
                success: true,
                settings: {
                    provider: args[0]?.provider || 'openai',
                    model: args[0]?.model || (args[0]?.provider === 'anthropic' ? 'claude-3-5-haiku-latest' : args[0]?.provider === 'ollama' ? 'llama3.2' : 'gpt-4o-mini'),
                    base_url: args[0]?.base_url || '',
                    api_key: args[0]?.api_key || '',
                    has_api_key: args[0]?.provider === 'ollama' ? true : !!(args[0]?.api_key)
                }
            }),
            ocr_page: () => ({
                success: true,
                lines: [
                    { text: 'Sample OCR text line 1', confidence: 0.95, x: 72, y: 700, width: 400, height: 14 },
                    { text: 'Another recognized line', confidence: 0.88, x: 72, y: 680, width: 350, height: 14 }
                ]
            }),
            ocr_document: () => ({
                success: true,
                page_count: 10,
                total_lines: 280,
                cached: false,
            }),
            start_ocr_document: () => ({
                success: true,
                started: true,
                cached: false,
                total_pages: 10,
            }),
            get_ocr_progress: () => ({
                success: true,
                status: 'completed',
                processed_pages: 10,
                total_pages: 10,
                total_lines: 280,
                percent: 100,
                error: '',
            }),
            get_app_info: () => ({
                name: 'DeepRead AI',
                version: '0.2.0 (Mock)'
            }),
            get_recent_files: () => ({
                success: true,
                files: []
            }),
            save_session_state: () => ({
                success: true
            }),
            save_page_notes: () => ({
                success: true,
                saved: Array.isArray(args[1]) ? args[1].length : 0
            }),
            delete_page_note: () => ({
                success: true
            })
        };

        return Promise.resolve(mocks[method] ? mocks[method]() : { success: false, error: 'Unknown method' });
    },

    // ==================== PDF Operations ====================

    /**
     * Open a PDF file
     * @param {string} filePath - Absolute path to PDF file
     * @returns {Promise<{success: boolean, page_count?: number, file_name?: string, error?: string}>}
     */
    async openPdf(filePath) {
        return this.call('open_pdf', filePath);
    },

    /**
     * Get a rendered page as base64 PNG
     * @param {number} pageNum - 1-based page number
     * @param {number} zoom - Zoom factor (1.0 = 100%)
     * @returns {Promise<{success: boolean, image_data?: string, page_width?: number, page_height?: number}>}
     */
    async getPage(pageNum, zoom = 1.0) {
        return this.call('get_page', pageNum, zoom);
    },

    /**
     * Extract text from a page or region
     * @param {number} pageNum - 1-based page number
     * @param {Object|null} rect - Optional rectangle {x1, y1, x2, y2}
     * @returns {Promise<{success: boolean, text?: string}>}
     */
    async extractText(pageNum, rect = null) {
        return this.call('extract_text', pageNum, rect);
    },

    /**
     * Search for text in the PDF
     * @param {string} query - Search query
     * @param {number|null} pageNum - Optional specific page to search
     * @returns {Promise<{success: boolean, results?: Array}>}
     */
    async searchPdf(query, pageNum = null) {
        return this.call('search_pdf', query, pageNum);
    },

    /**
     * Get PDF metadata
     * @returns {Promise<{success: boolean, metadata?: Object}>}
     */
    async getPdfMetadata() {
        return this.call('get_pdf_metadata');
    },

    /**
     * Run OCR on a page and get text lines with bounding boxes
     * @param {number} pageNum - 1-based page number
     * @returns {Promise<{success: boolean, lines?: Array}>}
     */
    async ocrPage(pageNum) {
        return this.call('ocr_page', pageNum);
    },

    /**
     * Run OCR for the whole document and cache all pages
     * @returns {Promise<{success: boolean, page_count?: number, total_lines?: number, error?: string}>}
     */
    async ocrDocument() {
        return this.call('ocr_document');
    },

    /**
     * Start OCR for whole document in background
     */
    async startOcrDocument() {
        return this.call('start_ocr_document');
    },

    /**
     * Get OCR background task progress
     */
    async getOcrProgress() {
        return this.call('get_ocr_progress');
    },

    /**
     * Show file dialog and select PDF
     * @returns {Promise<{success: boolean, file_path?: string, cancelled?: boolean}>}
     */
    async selectPdfFile() {
        return this.call('select_pdf_file');
    },

    /**
     * Get recent files list
     * @param {number} limit - Max number of recent files
     * @returns {Promise<{success: boolean, files?: Array}>}
     */
    async getRecentFiles(limit = 20) {
        return this.call('get_recent_files', limit);
    },

    /**
     * Save document session state
     * @param {string} filePath - Absolute path to current PDF
     * @param {Object} state - {last_page, last_zoom, ocr_enabled, ocr_mode}
     * @returns {Promise<{success: boolean}>}
     */
    async saveSessionState(filePath, state) {
        return this.call('save_session_state', filePath, state);
    },

    /**
     * Save all page notes for a document
     * @param {string} filePath - Absolute path to current PDF
     * @param {Array} notes - Full note list for the document
     * @returns {Promise<{success: boolean, saved?: number}>}
     */
    async savePageNotes(filePath, notes) {
        return this.call('save_page_notes', filePath, notes);
    },

    /**
     * Delete a single page note
     * @param {string} filePath - Absolute path to current PDF
     * @param {string} noteId - Note id
     * @returns {Promise<{success: boolean}>}
     */
    async deletePageNote(filePath, noteId) {
        return this.call('delete_page_note', filePath, noteId);
    },

    // ==================== AI Operations ====================

    /**
     * Send chat message to AI
     * @param {string} message - User message
     * @param {string} context - Optional context (e.g., selected text)
     * @returns {Promise<{success: boolean, response?: string}>}
     */
    async aiChat(message, context = '') {
        return this.call('ai_chat', message, context);
    },

    /**
     * Read persisted AI provider settings
     * @returns {Promise<{success: boolean, settings?: Object, error?: string}>}
     */
    async getAiSettings() {
        return this.call('get_ai_settings');
    },

    /**
     * Persist and apply AI provider settings
     * @param {Object} settings - {provider, model, base_url, api_key}
     * @returns {Promise<{success: boolean, settings?: Object, error?: string}>}
     */
    async saveAiSettings(settings) {
        return this.call('save_ai_settings', settings);
    },

    /**
     * Perform AI action on selected text
     * @param {string} action - Action type (explain, summarize, translate, define)
     * @param {string} selectedText - Text to process
     * @returns {Promise<{success: boolean, response?: string}>}
     */
    async aiAction(action, selectedText) {
        return this.call('ai_action', action, selectedText);
    },

    /**
     * Perform quick action on document
     * @param {string} actionType - Type of action (full_summary, key_points, questions)
     * @param {string} documentContext - Context about the document
     * @returns {Promise<{success: boolean, response?: string}>}
     */
    async aiQuickAction(actionType, documentContext = '') {
        return this.call('ai_quick_action', actionType, documentContext);
    },

    // ==================== Note Operations ====================

    /**
     * Save a note
     * @param {string} noteId - Note ID (empty for new note)
     * @param {string} title - Note title
     * @param {string} content - Note content (markdown)
     * @returns {Promise<{success: boolean, note_id?: string}>}
     */
    async saveNote(noteId, title, content) {
        return this.call('save_note', noteId, title, content);
    },

    /**
     * Load a note by ID
     * @param {string} noteId - Note ID to load
     * @returns {Promise<{success: boolean, note?: Object}>}
     */
    async loadNote(noteId) {
        return this.call('load_note', noteId);
    },

    /**
     * List all saved notes
     * @returns {Promise<{success: boolean, notes?: Array}>}
     */
    async listNotes() {
        return this.call('list_notes');
    },

    /**
     * Delete a note
     * @param {string} noteId - Note ID to delete
     * @returns {Promise<{success: boolean}>}
     */
    async deleteNote(noteId) {
        return this.call('delete_note', noteId);
    },

    // ==================== Utility ====================

    /**
     * Get application information
     * @returns {Promise<{name: string, version: string}>}
     */
    async getAppInfo() {
        return this.call('get_app_info');
    }
};

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = API;
}
